From ed4c89c776ea65a68e9d87b6947173620da3d84a Mon Sep 17 00:00:00 2001
From: MyName <jankes040608@gmail.com>
Date: Wed, 29 Jan 2025 01:26:48 +0100
Subject: [PATCH] List7_Zad3

---
 Makefile   |  5 ++++-
 defs.h     |  4 ++++
 proc.c     |  8 ++++++++
 proc.h     |  2 ++
 syscall.c  | 31 +++++++++++++++++++++++++++++++
 syscall.h  |  2 ++
 sysproc.c  |  2 ++
 testFunc.c | 31 +++++++++++++++++++++++++++++++
 user.h     |  2 ++
 usys.S     |  2 ++
 10 files changed, 88 insertions(+), 1 deletion(-)
 create mode 100644 testFunc.c

diff --git a/Makefile b/Makefile
index 09d790c..fc90276 100644
--- a/Makefile
+++ b/Makefile
@@ -76,7 +76,7 @@ AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -mno-sse -ggdb -m32 -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -116,6 +116,7 @@ entryother: entryother.S
 
 initcode: initcode.S
 	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(OBJCOPY) --remove-section .note.gnu.property initcode.o
 	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
 	$(OBJCOPY) -S -O binary initcode.out initcode
 	$(OBJDUMP) -S initcode.o > initcode.asm
@@ -146,6 +147,7 @@ vectors.S: vectors.pl
 ULIB = ulib.o usys.o printf.o umalloc.o
 
 _%: %.o $(ULIB)
+	$(OBJCOPY) --remove-section .note.gnu.property ulib.o
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
 	$(OBJDUMP) -S $@ > $*.asm
 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
@@ -166,6 +168,7 @@ mkfs: mkfs.c fs.h
 .PRECIOUS: %.o
 
 UPROGS=\
+	_testFunc\
 	_cat\
 	_echo\
 	_forktest\
diff --git a/defs.h b/defs.h
index 82fb982..9c9e0f2 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,8 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct trapframe;
+
 
 // bio.c
 void            binit(void);
@@ -120,6 +122,8 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             sys_forkCb(void (*callback)());
+int             sys_exitCb(void);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/proc.c b/proc.c
index 806b1b1..e76883f 100644
--- a/proc.c
+++ b/proc.c
@@ -200,6 +200,14 @@ fork(void)
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
+  
+  if (curproc->callback) {
+    np->eipBackup = np->tf->eip;
+    np->tf->eip = (uint)curproc->callback;
+  } else {
+    np->eipBackup = 0;
+  }
+
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
diff --git a/proc.h b/proc.h
index 1647114..f2e59cb 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,8 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  void (*callback)(void);
+  uint eipBackup;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..3a75b03 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,8 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_forkCb(void (*callback)());
+extern int sys_exitCb(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +128,8 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_forkCb]  sys_forkCb,
+[SYS_exitCb]  sys_exitCb,
 };
 
 void
@@ -143,3 +147,30 @@ syscall(void)
     curproc->tf->eax = -1;
   }
 }
+
+int
+sys_forkCb(void (*callback)()){
+  void (*func)(void);
+
+  if (argptr(0, (char**)&func, sizeof(void*)) < 0){
+    return -1;
+  }
+
+  myproc()->callback = func;  
+  return 0;
+}
+
+int 
+sys_exitCb(void)
+{
+  struct proc *curproc = myproc();
+  
+  if (curproc->eipBackup == 0) {
+    return -1;  
+  }
+
+  curproc->tf->eip = curproc->eipBackup;
+  curproc->eipBackup = 0;
+
+  return 0;
+}
\ No newline at end of file
diff --git a/syscall.h b/syscall.h
index bc5f356..3f71d7f 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_forkCb 22
+#define SYS_exitCb 23
diff --git a/sysproc.c b/sysproc.c
index 0686d29..864b269 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,5 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+
diff --git a/testFunc.c b/testFunc.c
new file mode 100644
index 0000000..4a81ac6
--- /dev/null
+++ b/testFunc.c
@@ -0,0 +1,31 @@
+#include "types.h"
+#include "user.h"
+
+void testfunc(void) {
+  printf(1, "Funkcja wykonana przez dziecko!\n");
+  exitCb(); // Powr√≥t do oryginalnego kodu
+}
+
+int main() {
+  int pid;
+
+  printf(1, "Proces nadrzedny nie ustawia funkcji\n");
+  pid = fork();
+  if (pid == 0) {
+    printf(1, "Proces podrzedny bez funkcji\n");
+    exit();
+  }
+  wait();
+
+  printf(1, "Proces nadrzedny ustawia funkcje\n");
+  forkCb(&testfunc);
+  pid = fork();
+  if (pid == 0) {
+    printf(1, "Proces podrzedny z funkcja\n");
+    exit();
+  }
+  wait();
+
+  printf(1, "Test zakonczony\n");
+  exit();
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..b131e9c 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int forkCb(void (*func)(void));
+int exitCb(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..4c14f2b 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,5 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(forkCb)
+SYSCALL(exitCb)
-- 
2.43.0

